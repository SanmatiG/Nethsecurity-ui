{
  "version": 3,
  "sources": ["../../@xterm/addon-attach/lib/webpack:/AttachAddon/webpack/universalModuleDefinition", "../../@xterm/addon-attach/lib/webpack:/AttachAddon/src/AttachAddon.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AttachAddon\"] = factory();\n\telse\n\t\troot[\"AttachAddon\"] = factory();\n})(self, () => {\nreturn ", "/**\n * Copyright (c) 2014, 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n *\n * Implements the attach method, that attaches the terminal to a WebSocket stream.\n */\n\nimport type { Terminal, IDisposable, ITerminalAddon } from '@xterm/xterm';\nimport type { AttachAddon as IAttachApi } from '@xterm/addon-attach';\n\ninterface IAttachOptions {\n  bidirectional?: boolean;\n}\n\nexport class AttachAddon implements ITerminalAddon , IAttachApi {\n  private _socket: WebSocket;\n  private _bidirectional: boolean;\n  private _disposables: IDisposable[] = [];\n\n  constructor(socket: WebSocket, options?: IAttachOptions) {\n    this._socket = socket;\n    // always set binary type to arraybuffer, we do not handle blobs\n    this._socket.binaryType = 'arraybuffer';\n    this._bidirectional = !(options && options.bidirectional === false);\n  }\n\n  public activate(terminal: Terminal): void {\n    this._disposables.push(\n      addSocketListener(this._socket, 'message', ev => {\n        const data: ArrayBuffer | string = ev.data;\n        terminal.write(typeof data === 'string' ? data : new Uint8Array(data));\n      })\n    );\n\n    if (this._bidirectional) {\n      this._disposables.push(terminal.onData(data => this._sendData(data)));\n      this._disposables.push(terminal.onBinary(data => this._sendBinary(data)));\n    }\n\n    this._disposables.push(addSocketListener(this._socket, 'close', () => this.dispose()));\n    this._disposables.push(addSocketListener(this._socket, 'error', () => this.dispose()));\n  }\n\n  public dispose(): void {\n    for (const d of this._disposables) {\n      d.dispose();\n    }\n  }\n\n  private _sendData(data: string): void {\n    if (!this._checkOpenSocket()) {\n      return;\n    }\n    this._socket.send(data);\n  }\n\n  private _sendBinary(data: string): void {\n    if (!this._checkOpenSocket()) {\n      return;\n    }\n    const buffer = new Uint8Array(data.length);\n    for (let i = 0; i < data.length; ++i) {\n      buffer[i] = data.charCodeAt(i) & 255;\n    }\n    this._socket.send(buffer);\n  }\n\n  private _checkOpenSocket(): boolean {\n    switch (this._socket.readyState) {\n      case WebSocket.OPEN:\n        return true;\n      case WebSocket.CONNECTING:\n        throw new Error('Attach addon was loaded before socket was open');\n      case WebSocket.CLOSING:\n        console.warn('Attach addon socket is closing');\n        return false;\n      case WebSocket.CLOSED:\n        throw new Error('Attach addon socket is closed');\n      default:\n        throw new Error('Unexpected socket state');\n    }\n  }\n}\n\nfunction addSocketListener<K extends keyof WebSocketEventMap>(socket: WebSocket, type: K, handler: (this: WebSocket, ev: WebSocketEventMap[K]) => any): IDisposable {\n  socket.addEventListener(type, handler);\n  return {\n    dispose: () => {\n      if (!handler) {\n        // Already disposed\n        return;\n      }\n      socket.removeEventListener(type, handler);\n    }\n  };\n}\n"],
  "mappings": ";;;;;;;KAAA,SAA2CA,GAAMC,GAAAA;AAC1B,kBAAA,OAAZC,WAA0C,YAAA,OAAXC,SACxCA,OAAOD,UAAUD,EAAAA,IACQ,cAAA,OAAXG,UAAyBA,OAAOC,MAC9CD,OAAO,CAAA,GAAIH,CAAAA,IACe,YAAA,OAAZC,UACdA,QAAqB,cAAID,EAAAA,IAEzBD,EAAkB,cAAIC,EAAAA;IACvB,EAAEK,MAAM,OAAA,MAAA;AAAA;AAAA,UAAA,IAAA,CAAA;AAAA,cAAA,MAAA;AAAA,YAAA,IAAA;AC2ET,iBAASC,EAAqDC,IAAmBC,IAASC,IAAAA;AAExF,iBADAF,GAAOG,iBAAiBF,IAAMC,EAAAA,GACvB,EACLE,SAAS,MAAA;AACFF,YAAAA,MAILF,GAAOK,oBAAoBJ,IAAMC,EAAAA;UAAQ,EAAA;QAG/C;AAAA,eAAA,eAAA,GAAA,cAAA,EAAA,OAAA,KAAA,CAAA,GAAA,EAAA,cAAA,QAjFA,EAAA,cAAA,MAAA;UAKE,YAAYF,IAAmBM,IAAAA;AAFvB,iBAAAC,eAA8B,CAAA,GAGpCC,KAAKC,UAAUT,IAEfQ,KAAKC,QAAQC,aAAa,eAC1BF,KAAKG,iBAAAA,EAAmBL,MAAAA,UAAWA,GAAQM;UAC7C;UAEO,SAASC,IAAAA;AACdL,iBAAKD,aAAaO,KAChBf,EAAkBS,KAAKC,SAAS,WAAWM,CAAAA,OAAAA;AACzC,oBAAMC,KAA6BD,GAAGC;AACtCH,cAAAA,GAASI,MAAsB,YAAA,OAATD,KAAoBA,KAAO,IAAIE,WAAWF,EAAAA,CAAAA;YAAM,CAAA,CAAA,GAItER,KAAKG,mBACPH,KAAKD,aAAaO,KAAKD,GAASM,OAAOH,CAAAA,OAAQR,KAAKY,UAAUJ,EAAAA,CAAAA,CAAAA,GAC9DR,KAAKD,aAAaO,KAAKD,GAASQ,SAASL,CAAAA,OAAQR,KAAKc,YAAYN,EAAAA,CAAAA,CAAAA,IAGpER,KAAKD,aAAaO,KAAKf,EAAkBS,KAAKC,SAAS,SAAS,MAAMD,KAAKJ,QAAAA,CAAAA,CAAAA,GAC3EI,KAAKD,aAAaO,KAAKf,EAAkBS,KAAKC,SAAS,SAAS,MAAMD,KAAKJ,QAAAA,CAAAA,CAAAA;UAC7E;UAEO,UAAAA;AACL,uBAAWmB,MAAKf,KAAKD,aACnBgB,CAAAA,GAAEnB,QAAAA;UAEN;UAEQ,UAAUY,IAAAA;AACXR,iBAAKgB,iBAAAA,KAGVhB,KAAKC,QAAQgB,KAAKT,EAAAA;UACpB;UAEQ,YAAYA,IAAAA;AAClB,gBAAA,CAAKR,KAAKgB,iBAAAA,EACR;AAEF,kBAAME,KAAS,IAAIR,WAAWF,GAAKW,MAAAA;AACnC,qBAASC,KAAI,GAAGA,KAAIZ,GAAKW,QAAAA,EAAUC,GACjCF,CAAAA,GAAOE,EAAAA,IAA0B,MAArBZ,GAAKa,WAAWD,EAAAA;AAE9BpB,iBAAKC,QAAQgB,KAAKC,EAAAA;UACpB;UAEQ,mBAAAF;AACN,oBAAQhB,KAAKC,QAAQqB,YAAAA;cACnB,KAAKC,UAAUC;AACb,uBAAA;cACF,KAAKD,UAAUE;AACb,sBAAM,IAAIC,MAAM,gDAAA;cAClB,KAAKH,UAAUI;AAEb,uBADAC,QAAQC,KAAK,gCAAA,GAAA;cAEf,KAAKN,UAAUO;AACb,sBAAM,IAAIJ,MAAM,+BAAA;cAClB;AACE,sBAAM,IAAIA,MAAM,yBAAA;YAAA;UAEtB;QAAA;MAAA,GAAA,GAAA;IAAA,GAAA,CAAA;;;",
  "names": ["root", "factory", "exports", "module", "define", "amd", "self", "addSocketListener", "socket", "type", "handler", "addEventListener", "dispose", "removeEventListener", "options", "_disposables", "this", "_socket", "binaryType", "_bidirectional", "bidirectional", "terminal", "push", "ev", "data", "write", "Uint8Array", "onData", "_sendData", "onBinary", "_sendBinary", "d", "_checkOpenSocket", "send", "buffer", "length", "i", "charCodeAt", "readyState", "WebSocket", "OPEN", "CONNECTING", "Error", "CLOSING", "console", "warn", "CLOSED"]
}
